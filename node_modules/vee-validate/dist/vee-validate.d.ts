import { Ref, ComputedRef, DefineComponent, VNode, RendererNode, RendererElement, ComponentOptionsMixin, VNodeProps, AllowedComponentProps, ComponentCustomProps } from 'vue';
import { ObjectSchema } from 'yup';

interface ValidationResult {
    errors: string[];
}
declare type MaybeReactive<T> = Ref<T> | ComputedRef<T> | T;
declare type SubmitEvent = Event & {
    target: HTMLFormElement;
};
declare type GenericValidateFunction = (value: any) => boolean | string | Promise<boolean | string>;
interface FormContext<TValues extends Record<string, any> = Record<string, any>> {
    register(field: any): void;
    unregister(field: any): void;
    values: TValues;
    fields: ComputedRef<Record<keyof TValues, any>>;
    schema?: Record<keyof TValues, GenericValidateFunction | string | Record<string, any>> | ObjectSchema<TValues>;
    validateSchema?: (shouldMutate?: boolean) => Promise<Record<keyof TValues, ValidationResult>>;
    setFieldValue<T extends keyof TValues>(field: T, value: TValues[T]): void;
    setFieldError: (field: keyof TValues, message: string | undefined) => void;
    setErrors: (fields: Partial<Record<keyof TValues, string | undefined>>) => void;
    setValues<T extends keyof TValues>(fields: Partial<Record<T, TValues[T]>>): void;
    setFieldTouched: (field: keyof TValues, isTouched: boolean) => void;
    setTouched: (fields: Partial<Record<keyof TValues, boolean>>) => void;
    setFieldDirty: (field: keyof TValues, isDirty: boolean) => void;
    setDirty: (fields: Partial<Record<keyof TValues, boolean>>) => void;
    reset: () => void;
}
declare type SubmissionContext<TValues extends Record<string, any> = Record<string, any>> = {
    evt: SubmitEvent;
    form: FormContext<TValues>;
};
declare type SubmissionHandler<TValues extends Record<string, any> = Record<string, any>> = (values: TValues, ctx: SubmissionContext<TValues>) => any;

interface ValidationOptions {
    name?: string;
    values?: Record<string, any>;
    bails?: boolean;
    skipIfEmpty?: boolean;
    isInitial?: boolean;
}
/**
 * Validates a value against the rules.
 */
declare function validate(value: any, rules: string | Record<string, any> | GenericValidateFunction, options?: ValidationOptions): Promise<ValidationResult>;

interface FieldContext {
    field: string;
    value: any;
    form: Record<string, any>;
    rule?: {
        name: string;
        params?: Record<string, any> | any[];
    };
}
declare type ValidationRuleFunction = (value: any, params: any[] | Record<string, any>, ctx: FieldContext) => boolean | string | Promise<boolean | string>;
declare type ValidationMessageGenerator = (ctx: FieldContext) => string;

/**
 * Adds a custom validator to the list of validation rules.
 */
declare function defineRule(id: string, validator: ValidationRuleFunction): void;

interface VeeValidateConfig {
    bails: boolean;
    generateMessage: ValidationMessageGenerator;
    validateOnInput: boolean;
    validateOnChange: boolean;
    validateOnBlur: boolean;
    validateOnModelUpdate: boolean;
}
declare const configure: (newConf: Partial<VeeValidateConfig>) => void;

declare const Field: DefineComponent<{
    as: {
        type: (ObjectConstructor | StringConstructor)[];
        default: any;
    };
    name: {
        type: StringConstructor;
        required: true;
    };
    rules: {
        type: (ObjectConstructor | FunctionConstructor | StringConstructor)[];
        default: any;
    };
    validateOnMount: {
        type: BooleanConstructor;
        default: boolean;
    };
    bails: {
        type: BooleanConstructor;
        default: () => boolean;
    };
    label: {
        type: StringConstructor;
        default: any;
    };
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}> | VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>[], unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<{
    label: string;
    name: string;
    bails: boolean;
    validateOnMount: boolean;
    as: any;
    rules: any;
} & {}>, {
    label: string;
    bails: boolean;
    validateOnMount: boolean;
    as: any;
    rules: any;
}>;

declare const Form: DefineComponent<{
    as: {
        type: StringConstructor;
        default: string;
    };
    validationSchema: {
        type: ObjectConstructor;
        default: any;
    };
    initialValues: {
        type: ObjectConstructor;
        default: any;
    };
    validateOnMount: {
        type: BooleanConstructor;
        default: boolean;
    };
}, (this: any) => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}> | VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>[], unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<{
    validateOnMount: boolean;
    as: string;
    initialValues: Record<string, any>;
    validationSchema: Record<string, any>;
} & {}>, {
    validateOnMount: boolean;
    as: string;
    initialValues: Record<string, any>;
    validationSchema: Record<string, any>;
}>;

declare const ErrorMessage: DefineComponent<{
    as: {
        type: StringConstructor;
        default: any;
    };
    name: {
        type: StringConstructor;
        required: true;
    };
}, () => VNode<RendererNode, RendererElement, {
    [key: string]: any;
}> | VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>[], unknown, {}, {}, ComponentOptionsMixin, ComponentOptionsMixin, Record<string, any>, string, VNodeProps & AllowedComponentProps & ComponentCustomProps, Readonly<{
    name: string;
    as: string;
} & {}>, {
    as: string;
}>;

interface FieldOptions {
    initialValue: any;
    validateOnValueUpdate: boolean;
    validateOnMount?: boolean;
    bails?: boolean;
    type?: string;
    valueProp?: MaybeReactive<any>;
    label?: string;
}
declare type RuleExpression = MaybeReactive<string | Record<string, any> | GenericValidateFunction>;
/**
 * Creates a field composite.
 */
declare function useField(name: string, rules: RuleExpression, opts?: Partial<FieldOptions>): {
    name: string;
    value: any;
    meta: {
        touched: boolean;
        dirty: boolean;
        valid: boolean;
        pending: boolean;
        initialValue?: any;
    };
    errors: Ref<string[]>;
    errorMessage: ComputedRef<string>;
    type: string;
    valueProp: any;
    checked: ComputedRef<any>;
    idx: number;
    reset: () => void;
    validate: () => Promise<ValidationResult>;
    handleChange: (e: unknown) => Promise<ValidationResult>;
    handleBlur: () => void;
    handleInput: (e: unknown) => void;
    setValidationState: (result: ValidationResult) => ValidationResult;
    setTouched: (isTouched: boolean) => void;
    setDirty: (isDirty: boolean) => void;
};

interface FormOptions<TValues extends Record<string, any>> {
    validationSchema?: Record<keyof TValues, GenericValidateFunction | string | Record<string, any>> | ObjectSchema<TValues>;
    initialValues?: MaybeReactive<TValues>;
    validateOnMount?: boolean;
}
declare function useForm<TValues extends Record<string, any> = Record<string, any>>(opts?: FormOptions<TValues>): {
    errors: ComputedRef<{ [P in keyof TValues]?: string; }>;
    meta: ComputedRef<{
        pending: boolean;
        touched: boolean;
        dirty: boolean;
        valid: boolean;
        initialValues: TValues;
    }>;
    values: TValues;
    validate: () => Promise<boolean>;
    isSubmitting: Ref<boolean>;
    handleReset: () => void;
    handleSubmit: (fn?: SubmissionHandler<TValues>) => (e: unknown) => Promise<void>;
    submitForm: (e: unknown) => Promise<void>;
    setFieldError: (field: keyof TValues, message: string | undefined) => void;
    setErrors: (fields: Partial<Record<keyof TValues, string | undefined>>) => void;
    setFieldValue: <T extends keyof TValues = string>(field: T, value: TValues[T]) => void;
    setValues: (fields: Partial<TValues>) => void;
    setFieldTouched: (field: keyof TValues, isTouched: boolean) => void;
    setTouched: (fields: Partial<Record<keyof TValues, boolean>>) => void;
    setFieldDirty: (field: keyof TValues, isDirty: boolean) => void;
    setDirty: (fields: Partial<Record<keyof TValues, boolean>>) => void;
};

export { ErrorMessage, Field, Form, configure, defineRule, useField, useForm, validate };
